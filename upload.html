<!doctype html>
<html lang="bg">
    <head>
        <meta charset="utf-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
        />
        <title>Iris Overlay [BIOTECH UPGRADE] — Biotech Mobile</title>
        <style>
            :root {
                /* Light theme for the page background and panels */
                --bg: #f0f2f5;
                --panel: #ffffff;
                --text: #14171a;

                /* Vibrant "biotech" colors for the SVG overlay from upload.html */
                --muted: #7a8a9a;
                --primary: #00f0ff;
                --accent: #ff00cc;
                --glow: #00e0ff;
                --success: #00ff8c;
            }
            html,
            body {
                height: 100%;
                margin: 0;
                background: var(--bg);
                color: var(--text);
                font-family:
                    system-ui,
                    -apple-system,
                    Segoe UI,
                    Roboto,
                    Arial,
                    sans-serif;
                overflow: hidden;
            }
            .app {
                display: flex;
                flex-direction: column;
                height: 100%;
            }
            .stage-wrap {
                position: relative;
                flex: 1;
                overflow: hidden;
                background: var(--bg);
                display: flex;
                align-items: center;
                justify-content: center;
                touch-action: none;
            }
            /* The circular viewport with the soft blue glow */
            .photo-viewport {
                width: min(88vh, 88vw);
                height: min(88vh, 88vw);
                position: absolute;
                border-radius: 50%;
                overflow: hidden; /* This clips the image */
                background: #e0e2e5; /* Fallback background */
                box-shadow: 0 0 25px 8px rgba(0, 170, 255, 0.25); /* Soft blue glow */
            }
            .photo {
                position: absolute;
                max-width: none;
                transform-origin: center center;
                will-change: transform;
            }
            .overlay-wrap {
                position: absolute;
                width: min(88vh, 88vw);
                height: min(88vh, 88vw);
                pointer-events: none;
            }
            .panel {
                background: var(--panel);
                padding: 12px;
                border-top: 1px solid #e0e2e5;
                box-shadow: 0 -8px 24px rgba(0, 0, 0, 0.05);
                z-index: 10;
            }
            .row {
                display: flex;
                gap: 8px;
                align-items: center;
                flex-wrap: wrap;
            }
            input[type='file'] {
                flex: 1;
                color: #657786;
                background: #e9ecef;
                border: 1px solid #ced4da;
                padding: 8px;
                border-radius: 8px;
            }
            /* The styled blue button */
            button {
                background: linear-gradient(135deg, #0077ff, #00aaff);
                color: white;
                border: none;
                padding: 9px 16px;
                border-radius: 8px;
                font-weight: 600;
                box-shadow: 0 4px 14px rgba(0, 122, 255, 0.3);
            }
            button:active {
                transform: scale(0.96);
                background: linear-gradient(135deg, #0066dd, #0099ee);
            }
            .hint {
                font-size: 12px;
                color: #657786;
                margin-top: 6px;
                text-align: center;
            }

            /* --- Futuristic Biotech Overlay Styles (Using new colors) --- */
            svg {
                display: block;
                filter: drop-shadow(0 0 8px rgba(0, 240, 255, 0.35));
            }

            .sector-line {
                stroke: var(--primary);
                stroke-width: 1.5;
                stroke-opacity: 0.4;
            }

            .ring-main {
                stroke: var(--primary);
                stroke-width: 2.5;
                stroke-opacity: 0.8;
                fill: none;
            }

            .ring-dashed {
                stroke: var(--primary);
                stroke-width: 1;
                stroke-opacity: 0.4;
                fill: none;
                stroke-dasharray: 5, 8;
            }

            .outer-ring-grad {
                stroke: url(#ringGradient);
                stroke-width: 4;
                fill: none;
                filter: url(#outerGlow);
            }

            .center-dot {
                fill: var(--accent);
                filter: url(#centerGlow);
            }

            .crosshair-fine {
                stroke: var(--primary);
                stroke-width: 0.8;
                stroke-opacity: 0.3;
            }

            .marker-shape {
                fill: var(--accent);
                stroke: var(--accent);
                stroke-width: 1.5;
                opacity: 0.8;
            }

            .hex-grid {
                fill: url(#hexPattern);
                opacity: 0.1;
            }

            .targeting-bracket {
                stroke: var(--success);
                stroke-width: 2.5;
                fill: none;
                opacity: 0.7;
            }

            .data-text {
                font-family: 'Lucida Console', 'Courier New', monospace;
                font-size: 16px;
                font-weight: 700;
                fill: var(--primary);
                text-shadow: 0 0 5px var(--glow);
                text-anchor: middle;
            }

            .data-text-small {
                font-size: 14px;
                fill: var(--muted);
                text-anchor: start;
            }
        </style>
    </head>
    <body>
        <div class="app">
            <div class="stage-wrap" id="stageWrap">
                <!-- This container is the circular mask -->
                <div class="photo-viewport">
                    <img id="photo" class="photo" alt="photo" style="display: none" />
                </div>

                <!-- The overlay sits on top of the clipped photo -->
                <div class="overlay-wrap">
                    <svg
                        id="overlay"
                        viewBox="-400 -400 800 800"
                        width="100%"
                        height="100%"
                        aria-label="Futuristic iris scanner overlay"
                    >
                        <defs>
                            <!-- Filters for Glows -->
                            <filter id="outerGlow">
                                <feGaussianBlur stdDeviation="6" result="blur" />
                            </filter>
                            <filter id="centerGlow">
                                <feGaussianBlur stdDeviation="4" result="blur" />
                            </filter>

                            <!-- Gradient for Outer Ring -->
                            <linearGradient id="ringGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color: var(--accent)" />
                                <stop offset="50%" style="stop-color: var(--primary)" />
                                <stop offset="100%" style="stop-color: var(--accent)" />
                            </linearGradient>

                            <!-- Hexagon pattern -->
                            <pattern
                                id="hexPattern"
                                width="30"
                                height="26"
                                patternUnits="userSpaceOnUse"
                                patternTransform="scale(1.5)"
                            >
                                <path
                                    d="M15 0 L30 7.5 L30 22.5 L15 30 L0 22.5 L0 7.5 Z"
                                    fill="none"
                                    stroke="var(--primary)"
                                    stroke-width="1.2"
                                />
                            </pattern>
                        </defs>

                        <!-- Main Group for HUD Elements -->
                        <g id="hud-elements">
                            <!-- Subtle Hexagonal Grid Background -->
                            <circle r="335" class="hex-grid" />

                            <!-- Faint grid circles -->
                            <circle r="120" class="ring-dashed" />
                            <circle
                                r="200"
                                class="ring-main"
                                stroke-width="1.5"
                                stroke-opacity="0.5"
                            />
                            <circle r="260" class="ring-dashed" stroke-dasharray="80, 10" />
                            <circle r="320" class="ring-main" />

                            <!-- Sector lines (every 30 degrees) -->
                            <g class="sector-line">
                                <line x1="0" y1="-80" x2="0" y2="-320" transform="rotate(0)" />
                                <line x1="0" y1="-80" x2="0" y2="-320" transform="rotate(30)" />
                                <line x1="0" y1="-80" x2="0" y2="-320" transform="rotate(60)" />
                                <line x1="0" y1="-80" x2="0" y2="-320" transform="rotate(90)" />
                                <line x1="0" y1="-80" x2="0" y2="-320" transform="rotate(120)" />
                                <line x1="0" y1="-80" x2="0" y2="-320" transform="rotate(150)" />
                                <line x1="0" y1="-80" x2="0" y2="-320" transform="rotate(180)" />
                                <line x1="0" y1="-80" x2="0" y2="-320" transform="rotate(210)" />
                                <line x1="0" y1="-80" x2="0" y2="-320" transform="rotate(240)" />
                                <line x1="0" y1="-80" x2="0" y2="-320" transform="rotate(270)" />
                                <line x1="0" y1="-80" x2="0" y2="-320" transform="rotate(300)" />
                                <line x1="0" y1="-80" x2="0" y2="-320" transform="rotate(330)" />
                            </g>

                            <!-- Triangular Markers on outer ring -->
                            <g class="marker-shape">
                                <path d="M -8 -320 L 8 -320 L 0 -335 Z" transform="rotate(0)" />
                                <path d="M -8 -320 L 8 -320 L 0 -335 Z" transform="rotate(30)" />
                                <path d="M -8 -320 L 8 -320 L 0 -335 Z" transform="rotate(60)" />
                                <path d="M -8 -320 L 8 -320 L 0 -335 Z" transform="rotate(90)" />
                                <path d="M -8 -320 L 8 -320 L 0 -335 Z" transform="rotate(120)" />
                                <path d="M -8 -320 L 8 -320 L 0 -335 Z" transform="rotate(150)" />
                                <path d="M -8 -320 L 8 -320 L 0 -335 Z" transform="rotate(180)" />
                                <path d="M -8 -320 L 8 -320 L 0 -335 Z" transform="rotate(210)" />
                                <path d="M -8 -320 L 8 -320 L 0 -335 Z" transform="rotate(240)" />
                                <path d="M -8 -320 L 8 -320 L 0 -335 Z" transform="rotate(270)" />
                                <path d="M -8 -320 L 8 -320 L 0 -335 Z" transform="rotate(300)" />
                                <path d="M -8 -320 L 8 -320 L 0 -335 Z" transform="rotate(330)" />
                            </g>

                            <!-- Prominent outer ring with gradient -->
                            <circle r="350" class="outer-ring-grad" />

                            <!-- Center sensor complex -->
                            <g class="center-dot-complex">
                                <circle r="10" class="center-dot" />
                                <circle
                                    r="25"
                                    fill="none"
                                    stroke="var(--accent)"
                                    stroke-width="1.5"
                                    opacity="0.6"
                                />
                                <circle
                                    r="35"
                                    class="ring-dashed"
                                    stroke-width="1"
                                    stroke-opacity="0.5"
                                />
                                <g class="crosshair-fine">
                                    <line x1="-50" y1="0" x2="50" y2="0" />
                                    <line x1="0" y1="-50" x2="0" y2="50" />
                                </g>
                            </g>

                            <!-- Targeting Brackets / HUD Elements -->
                            <g class="targeting-bracket">
                                <path d="M -250 -350 L -300 -350 L -300 -300" />
                                <path d="M  250 -350 L  300 -350 L  300 -300" />
                                <path d="M -250  350 L -300  350 L -300  300" />
                                <path d="M  250  350 L  300  350 L  300  300" />
                            </g>

                            <!-- Data readouts -->
                            <g class="data-text">
                                <text x="0" y="-285">ID: 84-TRX</text>
                                <text x="230" y="-230" font-size="24" fill="var(--success)">
                                    STBL
                                </text>
                                <text
                                    x="-285"
                                    y="0"
                                    text-anchor="end"
                                    class="data-text-small"
                                    transform="rotate(-90, -285, 0)"
                                >
                                    SEQ. ACTIVE
                                </text>
                                <text
                                    x="285"
                                    y="0"
                                    text-anchor="start"
                                    class="data-text-small"
                                    transform="rotate(90, 285, 0)"
                                >
                                    LUM: 98.4
                                </text>
                            </g>
                        </g>
                        <!-- The background masking path has been REMOVED -->
                    </svg>
                </div>
            </div>

            <div class="panel">
                <div class="row">
                    <input id="file" type="file" accept="image/*" />
                    <button id="btnReset">Нулиране</button>
                </div>
                <div class="hint">
                    С един пръст местиш снимката. С два пръста приближаваш/отдалечаваш.
                </div>
            </div>
        </div>

        <script>
            (function () {
                // The script now targets stageWrap for events, which covers the whole area.
                const stageWrap = document.getElementById('stageWrap');
                const img = document.getElementById('photo');
                const file = document.getElementById('file');
                const btnReset = document.getElementById('btnReset');

                // Transform state (NO rotation)
                let state = {
                    scale: 1,
                    tx: 0,
                    ty: 0,
                    pointers: new Map(),
                    startDist: 0,
                    startScale: 1,
                    startMid: { x: 0, y: 0 },
                    startTx: 0,
                    startTy: 0,
                    last: null
                };

                function applyTransform() {
                    img.style.transform = `translate(${state.tx}px, ${state.ty}px) scale(${state.scale})`;
                }

                function reset() {
                    state.scale = 1;
                    state.tx = 0;
                    state.ty = 0;
                    applyTransform();
                }

                btnReset.addEventListener('click', reset);

                // Load file from gallery
                function loadFile(f) {
                    const url = URL.createObjectURL(f);
                    img.onload = () => {
                        img.style.display = 'block';
                        reset();
                    };
                    img.src = url;
                }
                file.addEventListener('change', (e) => {
                    const f = e.target.files && e.target.files[0];
                    if (!f) return;
                    loadFile(f);
                });

                // Pointer events for pan (1 finger) / pinch-zoom (2 fingers), NO rotation
                stageWrap.addEventListener('pointerdown', (e) => {
                    if (img.style.display === 'none') return;
                    // Capture events on the whole stage, not the image, to avoid losing pointer on fast drags
                    stageWrap.setPointerCapture(e.pointerId);
                    state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
                    if (state.pointers.size === 1) {
                        const p = state.pointers.values().next().value;
                        state.last = { x: p.x, y: p.y };
                    }
                    if (state.pointers.size === 2) {
                        const pts = Array.from(state.pointers.values());
                        state.startDist = Math.hypot(pts[1].x - pts[0].x, pts[1].y - pts[0].y);
                        state.startScale = state.scale;
                        state.startMid = {
                            x: (pts[0].x + pts[1].x) / 2,
                            y: (pts[0].y + pts[1].y) / 2
                        };
                        state.startTx = state.tx;
                        state.startTy = state.ty;
                    }
                });
                stageWrap.addEventListener('pointermove', (e) => {
                    if (!state.pointers.has(e.pointerId)) return;
                    state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
                    if (state.pointers.size === 1) {
                        const p = state.pointers.values().next().value;
                        if (!state.last) state.last = { x: p.x, y: p.y };
                        const dx = p.x - state.last.x;
                        const dy = p.y - state.last.y;
                        state.tx += dx;
                        state.ty += dy;
                        state.last = { x: p.x, y: p.y };
                        applyTransform();
                    } else if (state.pointers.size === 2) {
                        const pts = Array.from(state.pointers.values());
                        const dist = Math.hypot(pts[1].x - pts[0].x, pts[1].y - pts[0].y);
                        if (state.startDist > 0) {
                            // Adjust scale based on pinch
                            const k = dist / state.startDist;
                            state.scale = Math.min(5, Math.max(0.3, state.startScale * k));

                            // Adjust translation to zoom towards the midpoint of the fingers
                            const currentMid = {
                                x: (pts[0].x + pts[1].x) / 2,
                                y: (pts[0].y + pts[1].y) / 2
                            };
                            const newTx = state.startTx + (currentMid.x - state.startMid.x);
                            const newTy = state.startTy + (currentMid.y - state.startMid.y);
                            state.tx = newTx;
                            state.ty = newTy;

                            applyTransform();
                        }
                    }
                });
                function endPointer(e) {
                    if (stageWrap.hasPointerCapture(e.pointerId))
                        stageWrap.releasePointerCapture(e.pointerId);
                    state.pointers.delete(e.pointerId);
                    if (state.pointers.size < 2) {
                        state.startDist = 0;
                    }
                    if (state.pointers.size === 0) {
                        state.last = null;
                    }
                    // If one finger remains, reset its 'last' position to prevent jumps
                    else if (state.pointers.size === 1) {
                        const p = state.pointers.values().next().value;
                        state.last = { x: p.x, y: p.y };
                    }
                }
                stageWrap.addEventListener('pointerup', endPointer);
                stageWrap.addEventListener('pointercancel', endPointer);
                stageWrap.addEventListener('pointerleave', (e) => {
                    if (state.pointers.has(e.pointerId)) endPointer(e);
                });
            })();
        </script>
    </body>
</html>
