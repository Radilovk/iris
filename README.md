# Iris-Holistica AI Backend

Този проект съдържа Cloudflare Worker, който изпълнява многостъпков RAG анализ на ирисови изображения.

## Идея на проекта

Iris-Holistica AI автоматизира иридологичния анализ чрез комбиниране на класически знания и съвременни AI модели. Потребителят изпраща снимки на ириси и кратка анамнеза, а системата връща структурирано тълкуване и холистични насоки.

Той служи като помощник на иридолози и любители, предоставяйки бърз първоначален обзор. Алгоритъмът съчетава текстове от български и международни учебници с генеративни модели, за да изведе ясно и разбираемо обобщение. Резултатът не е медицинска диагноза, а ориентир, който подпомага консултация със специалист и промяна в начина на живот.

**Пример**

```bash
curl -F "left-eye=@left.jpg" -F "right-eye=@right.jpg" \
     -F "name=Мария" -F "age=34" \
     https://iris.example.com/analyze
```

## Основи на реализацията

Проектът се реализира като Cloudflare Worker, който работи без зависимости към браузърни API и обединява логиката в `worker.js`. Той:

- приема `FormData` с изображение на ляво и дясно око и допълнителни данни;
- използва избрания AI доставчик (**Gemini** или **OpenAI**) за идентифициране на знаци;
- извлича знания от RAG паметта (Cloudflare KV) и генерира финален анализ.

### Архитектура и зависимости

- **Cloudflare Worker** – изпълнява основната логика в сървърлес среда;
- **Cloudflare KV** – служи като RAG памет и хранилище за резултатите;
- **Фронтенд** – статични `index.html` и `script.js` с минимален CSS дизайн;
- **AI доставчици** – OpenAI или Gemini, избирани според конфигурацията.

Основният вход на работника:

```js
export default {
  async fetch(request, env) {
    return handleAnalyzeRequest(request, env);
  }
}
```

**Примерна интеграция в браузъра**

```js
fetch(WORKER_URL, { method: 'POST', body: formData })
  .then(r => r.json())
  .then(data => console.log(data.summary));
```

## Работен поток: от заявката до отговора

1. **Качване** – фронтендът събира изображения и данни и ги изпраща към `/analyze`.
   - `formData.append('left-eye', file)`
2. **Валидация** – `worker.js` проверява размера на файловете и наличието на ключове.
   - `if (file.size > 5*1024*1024) compress(file);`
3. **Предобработка и идентификация на знаци** – снимките се преобразуват в Base64 и чрез промпт се извличат RAG ключове (напр. `["SIGN_IRIS_RING_CONTRACTION_FURROWS"]`).
   - промпт: `Опиши наличните знаци като JSON...`
4. **RAG извличане** – `fetchRagData` зарежда съответните JSON записи от KV кеширано.
   - `cache[key] || await env.RAG.get(key)`
5. **Синтез** – втори AI повик генерира крайния JSON анализ и добавя разширен дисклеймър.
   - `generateSummary(signs, ragRecords)`
6. **Отговор** – резултатът се връща на клиента и се записва в KV за последващ преглед.
   - `await env.RESULTS.put(id, JSON.stringify(result))`

**Очакван JSON отговор**

```json
{
  "summary": "Общо добро състояние...",
  "signs": { "SIGN_IRIS_RING_CONTRACTION_FURROWS": "налични" },
  "holistic_analysis": "..."
}
```

## RAG памет

Паметта се съхранява в Cloudflare KV namespace **`iris_rag_kv`**. Всеки файл в директорията [`KV/`](KV/) представлява JSON документ с ключ като името на файла. Основни групи:

- `SIGN_` – описания на ирисови и склерални знаци;
- `BOOK_` – откъси от учебници и източници;
- `DISPOSITION_`, `CONSTITUTION_`, `RECOMMENDATION_` – базови модели и насоки.

Структурата е плоска, а името на файла съвпада с ключа в KV. Всеки JSON следва базова схема:

```json
{
  "name": "...",
  "interpretation": "...",
  "source": "Учебник X, стр. 12",
  "support": ["съвет 1", "съвет 2"]
}
```

**Добавяне на нов запис**

1. създайте `KV/SIGN_MY_KEY.json`;
2. попълнете полетата според схемата;
3. изпълнете `npm run upload-kv` за синхронизация.

Функцията `fetchRagData` кешира резултатите в глобален обект `CACHE` за 10 минути, което намалява латентността и броя KV заявки. При липса на ключове работникът връща генерален съвет и избягва халюцинации.

**Примерен KV запис**

```json
{
  "name": "Нервни пръстени",
  "interpretation": "Показват хроничен стрес...",
  "support": "Медитация, магнезий, билки-нервини"
}
```

Ботът очаквано:

- отговаря само на български;
- използва предоставените RAG знания без да измисля факти;
- приключва всеки анализ с разширен дисклеймър за немедицински характер.

## Насоки за разработчици

- Централна логика: [`worker.js`](worker.js);
- Клиентски код и форма за качване: [`index.html`](index.html), [`script.js`](script.js);
- RAG съдържание: [`KV/`](KV/), синхронизация чрез `npm run upload-kv`;
- Базови тестове: [`worker.test.js`](worker.test.js) – изпълнявайте `npm test` при промени.

Придържайте се към функционален стил без глобални странични ефекти. Всеки нов модул трябва да бъде придружен с кратък пример и тест. UI файловете използват неутрална цветова схема и семантични HTML елементи за достъпност.

## Потребителски интерфейс и дизайн

Фронтендът е минималистичен – една страница `index.html` със стилове в `style.css`. Форма за качване на снимки и текстови полета са центрирани и адаптивни.

```html
<form id="upload">
  <input type="file" name="left-eye" />
  <input type="file" name="right-eye" />
  <button>Анализирай</button>
</form>
```

Административният интерфейс `admin.html` позволява добавяне на модели и доставчици. Промените в дизайна трябва да запазят чист фон, ясни бутони и ARIA атрибути за достъпност.

## Идеи за оптимизация

- Разширяване на тестовете с реални образи за по-добра стабилност;
- Автоматично валидационно ниво преди качване на нови RAG записи;
- Добавяне на ESLint/Prettier и TypeScript за по-лесна поддръжка.
- Кеширане на отговорите на AI и събиране на телеметрия за анализ на производителността;
- Поточно връщане на частични резултати за по-бърза обратна връзка;
- Автоматично генериране на миниатюри за качените изображения.

## Cloudflare Worker

Всички функции на работника трябва да се съдържат в един файл `worker.js`. Забранено е използването на `localStorage`, DOM или други браузърни API.

```md
**Важно:** `worker.js` се деплойва самостоятелно. Не използвайте `import` към локални модули, нито браузърни обекти като `window` или `localStorage`.
```

## Конфигурация на Worker URL

Фронтендът използва конфигурационен файл [`config.js`](config.js), за да определи адреса на Cloudflare Worker-а.

```js
// config.js
export const WORKER_URL =
  (typeof process !== 'undefined' && process.env && process.env.WORKER_URL) ||
  (typeof window !== 'undefined' && window.WORKER_URL) ||
  'https://iris.radilov-k.workers.dev/analyze';
```

### Задаване през environment променлива

При разработка може да зададете URL-а чрез променлива на средата:

```bash
export WORKER_URL="https://my-worker.example.com/analyze"
```

### Ръчно задаване

Алтернативно, редактирайте `config.js` и променете стойността по подразбиране.

## Подробно логване

По подразбиране логовете са минимални. За да активирате подробното логване:

```toml
[vars]
DEBUG = "true"
```

Добавете горното в `wrangler.toml` или задайте променливата `DEBUG` в облачната среда. За да изключите логовете, задайте:

```toml
[vars]
DEBUG = "false"
```

При активиран `DEBUG` се записват и причини за отказ, например липсващ API ключ.

### Филтриране на логове в Cloudflare Logs

За да прегледате само информационните съобщения, например при липсващ API ключ:

```bash
wrangler tail --log-level=info --search "API ключът липсва"
```

## Избор на AI доставчик

Работникът поддържа два доставчика на модели – **Gemini** и **OpenAI**. 
Изберете кой да се използва чрез променливата на средата `AI_PROVIDER`:

```toml
[vars]
AI_PROVIDER = "openai" # или "gemini" (по подразбиране)
```

Ако не зададете стойност, автоматично се избира `"gemini"`.

## Избор на AI модел

Моделът може да се зададе чрез `AI_MODEL`. Ако липсва, работникът използва
`AI_MODEL_EXTENDED` като стойност по подразбиране. При отсъствие на двете се
избира модел според доставчика (`gpt-4o` за OpenAI и `gemini-1.5-pro` за
Gemini).

```toml
[vars]
AI_MODEL_EXTENDED = "gpt-4o" # примерна стойност
```

## OpenAI API ключ

За да използвате моделите на OpenAI, задайте API ключа в `wrangler.toml` или като секрет:

```toml
[vars]
openai_api_key = "YOUR_KEY"  # или използвайте OPENAI_API_KEY
```

или чрез командата:

```bash
wrangler secret put openai_api_key
```

## Gemini API ключ

За Gemini задайте ключа по аналогичен начин:

```toml
[vars]
gemini_api_key = "YOUR_KEY"  # или използвайте GEMINI_API_KEY
```

или чрез командата:

```bash
wrangler secret put gemini_api_key
```

## Google Custom Search API

За външни източници се използва Google Custom Search. Настройте ключ и идентификатор:

```toml
[vars]
GOOGLE_API_KEY = "demo-key"
GOOGLE_CX = "demo-cx"
```

## Първоначално конфигуриране

1. Отворете `admin.html` в браузър.
2. Ако списъкът с доставчици е празен, приложението автоматично добавя `gemini` и модел `gemini-1.5-pro`.
3. За да въведете свой модел:
   - изберете доставчик от падащото меню;
   - въведете името на модела и натиснете **Добави**.

## Допълнителни бележки
- Логовете не съдържат чувствителни данни; отговорите от AI се съкращават.
- Използвайте режим на разработка само за тестови цели.

## Компресия на големи изображения
Изображенията се компресират и преобразуват до WebP още в браузъра, преди да бъдат изпратени към worker-а.

```js
const { data, type } = await fileToBase64(largeFile); // връща Base64 + MIME тип без допълнителна компресия
```

## Синхронизация с Cloudflare KV

В директорията [`KV`](KV/) се съхраняват всички ключове и стойности, които трябва да бъдат налични в пространството **`iris_rag_kv`**. Преди качване задайте променливите `CF_ACCOUNT_ID`, `CF_KV_NAMESPACE_ID` и `CF_API_TOKEN` (в `.env` или в CI/CD):

```bash
export CF_ACCOUNT_ID="<your-account-id>"
export CF_KV_NAMESPACE_ID="<namespace-id>"
export CF_API_TOKEN="<api-token>"
npm run upload-kv
```

### Локална конфигурация чрез `.env`

За удобство при разработка можете да създадете файл `.env` (на база на [`\.env.example`](.env.example)) и да попълните нужните променливи:

```bash
cp .env.example .env
# редактирайте стойностите според вашата среда
```

Скриптовете, включително `upload-kv.js`, автоматично зареждат този файл чрез библиотеката **dotenv**.

Скриптът използва [Cloudflare KV Bulk API](https://developers.cloudflare.com/api/operations/kv-namespace-write-multiple-key-value-pairs) и качва съдържанието на всички файлове в `KV` директорията. При неуспех се извежда описателна грешка.

Преди качването се извличат съществуващите ключове (`GET /keys`) за избрания namespace. Липсващите локални файлове се маркират за изтриване чрез `delete` в bulk заявката. Скриптът логва кои ключове ще бъдат обновени и кои – премахнати.

Примерна сесия:

```bash
npm run upload-kv
# Ще бъдат обновени ключове: SIGN_IRIS_RING_CONTRACTION_FURROWS
# Ще бъдат изтрити ключове: OLD_KEY
```

Така директорията `KV/` служи като източник на истина за съдържанието в Cloudflare KV и позволява синхронизация само с една команда.

### Автоматична синхронизация при промени

За удобство при разработка можете да стартирате наблюдател, който следи папката `KV/` и при всяка промяна валидира и качва ключовете:

```bash
npm run sync:kv
```

Скриптът изисква зададени променливи `CF_ACCOUNT_ID`, `CF_KV_NAMESPACE_ID` и `CF_API_TOKEN`.

### Автоматично обновяване в GitHub

След merge в `main` се изпълнява GitHub Action, което стартира `upload-kv.js` и синхронизира съдържанието на `KV/` с Cloudflare KV. За да работи, задайте в настройките на репозиторията Secrets `CF_ACCOUNT_ID`, `CF_KV_NAMESPACE_ID` и `CF_API_TOKEN`.
